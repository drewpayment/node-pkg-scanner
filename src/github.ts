import * as core from '@actions/core';
import * as github from '@actions/github';
import { ScanSummary } from './types';

export class GitHubIntegration {
  private octokit;
  private context;
  private hasValidToken: boolean;

  constructor(token?: string) {
    this.context = github.context;
    const finalToken = token || core.getInput('github-token') || process.env.GITHUB_TOKEN || '';
    this.hasValidToken = !!finalToken;
    
    if (this.hasValidToken) {
      this.octokit = github.getOctokit(finalToken);
    }
  }

  async postPRComment(summary: ScanSummary): Promise<void> {
    if (!this.hasValidToken) {
      console.log('GitHub token not available, skipping PR comment');
      return;
    }

    if (!this.context.payload.pull_request) {
      console.log('Not running in a pull request context, skipping comment');
      return;
    }

    const comment = this.generateComment(summary);
    
    try {
      await this.octokit!.rest.issues.createComment({
        owner: this.context.repo.owner,
        repo: this.context.repo.repo,
        issue_number: this.context.payload.pull_request.number,
        body: comment
      });
      
      console.log('✓ Posted comment to PR');
    } catch (error) {
      console.error('Failed to post PR comment:', error);
    }
  }

  private generateComment(summary: ScanSummary): string {
    const { compromisedPackages, scanResults, usingCachedList } = summary;
    
    let comment = '## 🚨 Compromised Node Package Detection\n\n';
    
    if (compromisedPackages.length === 0) {
      comment += '✅ **No compromised packages detected**\n\n';
      comment += `Scanned ${summary.totalFiles} package manager files.\n`;
    } else {
      comment += `❌ **Found ${compromisedPackages.length} compromised package(s)**\n\n`;
      comment += '### Compromised Packages Found:\n';
      
      for (const result of scanResults) {
        comment += `\n**${result.file}** (${result.packageManager}):\n`;
        for (const pkg of result.compromisedPackages) {
          comment += `- \`${pkg.name}\` ⚠️\n`;
        }
      }
      
      comment += '\n### ⚠️ Action Required\n';
      comment += 'These packages are known to be compromised. ';
      comment += 'Please remove them immediately and review your dependency security.\n\n';
      comment += '**References:**\n';
      comment += '- [Socket.dev Blog: Ongoing Supply Chain Attack](https://socket.dev/blog/ongoing-supply-chain-attack-targets-crowdstrike-npm-packages)\n';
      comment += '- [Compromised Packages List](https://github.com/Cobenian/shai-hulud-detect)\n';
    }
    
    if (usingCachedList) {
      comment += '\n> ⚠️ **Note:** Using cached compromised packages list (remote fetch failed)\n';
    }
    
    comment += '\n---\n';
    comment += '*Generated by [Node Package Scanner](https://github.com/drewpayment/node-package-scanner)*';
    
    return comment;
  }

  setOutputs(summary: ScanSummary): void {
    if (!this.hasValidToken) {
      console.log('GitHub token not available, skipping GitHub Actions outputs');
      return;
    }

    const hasCompromised = summary.compromisedPackages.length > 0;
    
    core.setOutput('compromised-found', hasCompromised.toString());
    core.setOutput('compromised-count', summary.compromisedPackages.length.toString());
    core.setOutput('compromised-packages', JSON.stringify(summary.compromisedPackages.map(p => p.name)));
    
    if (hasCompromised) {
      const severity = core.getInput('fail-on-error') === 'true' ? 'error' : 'warning';
      const message = `Found ${summary.compromisedPackages.length} compromised packages`;
      
      if (severity === 'error') {
        core.setFailed(message);
      } else {
        core.warning(message);
      }
    }
  }
}